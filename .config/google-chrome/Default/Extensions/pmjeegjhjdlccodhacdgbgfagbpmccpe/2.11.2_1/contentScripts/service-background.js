async function isNavigatorOffline(){const e=await localStorage.getItem("offline");return!e||JSON.parse(e)}function isChrome(){return"undefined"!=typeof chrome&&"undefined"==typeof browser}async function createHttpHeaders(e){let t={Accept:"application/json","Content-Type":"application/json"};e&&(t["X-Auth-Token"]=e);const a=await localStorage.getItem("wsConnectionId");a&&(t["socket-connection-id"]=a),t["App-Name"]="extension-"+(isChrome()?"chrome":"firefox"),t["App-Version"]=aBrowser.runtime.getManifest().version;const s=await localStorage.getItem("sub-domain_subDomainName");s&&(t["sub-domain-name"]=s);const r=await localStorage.getItem("lang");return r&&(t["accept-language"]=r),t}function errorObj(e,t,a){return{data:null,error:{status:e,message:t,errorData:a}}}class ClockifyService{constructor(){}static get userId(){return localStorage.getItem("userId")}static get userEmail(){return localStorage.getItem("userEmail")}static get workspaceId(){return localStorage.getItem("activeWorkspaceId")}static get apiEndpoint(){return localStorage.getItem("permanent_baseUrl")}static get user(){return localStorage.getItem("user")}static routesToCache=[{path:"/auth/token/refresh",expiresInMilliseconds:3e3},{path:"/timeEntries/recent?limit=",expiresInMilliseconds:1e3}];static cache={};static addToCache(e,t){this.cache[e]={...t,timestamp:(new Date).getTime()}}static removeFromCache(e){delete this.cache[e]}static requestQueue={};static isEndpointInRoutesToCache(e){return this.routesToCache.find((t=>e.includes(t.path)))}static async getForces(){const e=await localStorage.getItem("workspaceSettings"),t=await localStorage.getItem("userSettings"),a=e?JSON.parse(e):{forceDescription:!1,forceProjects:!1,forceTasks:!1,projectPickerSpecialFilter:!1,forceTags:!1},s=t?JSON.parse(t):{projectPickerSpecialFilter:!1},{forceDescription:r,forceProjects:o,forceTasks:n,forceTags:i}=a,{projectPickerSpecialFilter:c}=s;return{forceDescription:r,forceProjects:o,forceTasks:n,projectPickerSpecialFilter:c,forceTags:i}}static async getCreateObjects(){const e=await localStorage.getItem("permanent_createObjects");return!!e&&JSON.parse(e)}static async getCanCreateProjects(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateProjectsAndClients:a}=e?.entityCreationPermissions||{whoCanCreateProjectsAndClients:"ADMINS"};return"EVERYONE"===a||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===a&&t.includes("PROJECT_MANAGER")}static async getCanCreateTasks(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateTasks:a}=e?.entityCreationPermissions||{whoCanCreateTasks:"ADMINS"};return"EVERYONE"===a||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===a&&t.includes("PROJECT_MANAGER")}static async getCanCreateTags(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateTags:a}=e?.entityCreationPermissions||{whoCanCreateTags:"ADMINS"};return"EVERYONE"===a||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===a&&t.includes("PROJECT_MANAGER")}static async setOnline(){const e=await localStorage.getItem("offline");e&&"true"!==e||localStorage.setItem("offline","false")}static async setOffline(){const e=await localStorage.getItem("offline");e&&"false"!==e||localStorage.setItem("offline","true")}static async handleBannedResponse(e){const t=isChrome()?chrome:browser,a=e.message?.match(/Youâ€™ve been logged out since your ([a-f\d]{24}) workspace has been suspended\. Contact support@clockify\.me for more information/);if(a){const s=a[1];t.runtime.sendMessage({eventName:"WORKSPACE_BANNED",options:{...e,workspaceId:s}})}else(e.message?.includes("Access to workspace is denied")||e.message?.includes("account has been disabled"))&&t.runtime.sendMessage({eventName:"USER_BANNED",options:e})}static async apiCall(e,t="GET",a=null,s=!1,r){let o;if(s)o=null;else if(o=await TokenService.getToken(),!o)return errorObj("0","token is missing");const n=await createHttpHeaders(o),i=r?{...n,...r}:n,c=new Headers(i);e===`${await this.apiEndpoint}/auth/`&&c.delete("sub-domain-name");const l=this.isEndpointInRoutesToCache(e);if(l){const e=this.cache[l.path];if(e&&e.timestamp+l.expiresInMilliseconds>Date.now())return Promise.resolve(e);if(this.requestQueue[l.path]){const e=await this.requestQueue[l.path];return delete this.requestQueue[l.path],Promise.resolve(e)}}const u=new Request(e,{method:t,headers:c,body:a?JSON.stringify(a):null}),d=fetch(u).then((async e=>{let t;"error"===e.type?this.setOffline():this.setOnline();const a=[/Client with name '.*' already exists/,/.* project for client  already exists./,/Task name has to be between 1 and 1000 characters long/,/.* project for client .* already exists./,/Tag with name .* already exists/,/Manual time tracking disabled on .*/];switch(e.status){case 400:case 501:const{message:s}=await e.json();return errorObj(400,a.find((e=>e.test(s)))?s:`${clockifyLocales.YOU_ALREADY_HAVE_ENTRY_WITHOUT}. ${clockifyLocales.PLEASE_EDIT_YOUR_TIME_ENTRY}.`);case 403:if(t=await e.json(),t){if(406===t.code)return this.handleBannedResponse(t),errorObj(e.status,t?.message,t);if(4017===t.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:t}),errorObj(e.status,"Token invalid",t);if(4030===t.code)return errorObj(e.status,"Manual time tracking disabled",t);if(501===t.code)return errorObj(e.status,"Access Denied",t)}return errorObj(e.status,"Unauthenticated");case 404:return errorObj(e.status,"Not found");case 405:return errorObj(e.status,"Method not allowed");case 406:return t=await e.json(),this.handleBannedResponse(t),errorObj(e.status,"Banned",t);case 401:if(t=await e.json(),t){if(4019===t.code&&aBrowser.runtime.sendMessage({eventName:"VERIFY_EMAIL_ENFORCED",message:{}}).then((e=>{console.log(e)})).catch((e=>console.log(e))),406===t.code)return this.handleBannedResponse(t),errorObj(e.status,t?.message,t);if(4017===t.code||4023===t.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:t}),errorObj(e.status,"Token invalid",t);if(1e3===t.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:t}),errorObj(e.status,t)}return errorObj(e.status,"Forbidden")}let s;if(e.ok){try{s=await e.json()}catch{s=null}return l&&(this.addToCache(l.path,{data:s,error:null,status:e.status}),setTimeout((()=>{this.removeFromCache(l.path)}),l.expiresInMilliseconds)),{data:s,error:null,status:e.status}}{const t=await e.text();return errorObj(e.status,t)}})).catch((e=>(console.error("There has been a problem with your fetch operation: ",e),errorObj(0,e))));return l&&(this.requestQueue[l.path]=d),await d}}